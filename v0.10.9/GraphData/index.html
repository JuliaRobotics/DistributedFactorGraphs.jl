<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Using Graph Elements · DistributedFactorGraphs.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DistributedFactorGraphs.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Getting Started</span><ul><li><a class="toctext" href="../DataStructure/">DFG Data Structures</a></li><li><a class="toctext" href="../BuildingGraphs/">Building Graphs</a></li><li class="current"><a class="toctext" href>Using Graph Elements</a><ul class="internal"><li><a class="toctext" href="#Variable-and-Factor-Elements-1">Variable and Factor Elements</a></li><li><a class="toctext" href="#Graph-Related-Data-1">Graph-Related Data</a></li></ul></li><li><a class="toctext" href="../DrawingGraphs/">Drawing Graphs</a></li><li><a class="toctext" href="../ref_api/">Quick API Reference</a></li></ul></li><li><a class="toctext" href="../func_ref/">Function Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li>Getting Started</li><li><a href>Using Graph Elements</a></li></ul><a class="edit-page" href="https://github.com/JuliaRobotics/DistributedFactorGraphs.jl/blob/master/docs/src/GraphData.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Using Graph Elements</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Using-Graph-Elements-1" href="#Using-Graph-Elements-1">Using Graph Elements</a></h1><p>Variables and factors in DistributedFactorGraphs are used for a variety of different applications. We have tried to compartmentalize the data as much as possible so that users do not need to dig around to find what they need (it&#39;s a work in progress).</p><p>There are three fundamental types of data in DFG:</p><ul><li>Variable and factor data (stored in the nodes themselves)</li><li>Offloaded big data elements (keyed in a variable or factor, but stored in another location)</li><li>Graph data (data that is related to the graph itself)</li></ul><p>The following is a guideline to using these parameters.</p><p><strong>NOTE</strong>: Some functions are direct accessors to the internal parameters, others are derived functions (e.g. getLabel(v) = v.label). In other cases the accessors are simplified ways to interact with the structures. We recommend using the accessors as the internal structure may change over time.</p><p><strong>NOTE</strong>: Adds in general throw an error if the element already exists. Update will update the element if it exists, otherwise it will add it.</p><p><strong>NOTE</strong>: In general these functions will return an error if the respective element is not found. This is to avoid returning, say, nothing, which will be horribly confusing if you tried <code>getVariableSolverData(dfg, :a, :b)</code> and it returned nothing - which was missing, :a or :b, or was there a communication issue? We recommend coding defensively and trapping errors in critical portions of your user code.</p><p><strong>NOTE</strong>: All data is passed by reference, so if you update the returned structure it will update in the graph. The database driver is an exception, and once the variable or factor is updated you need to call update* to persist the changes to the graph.</p><p>The following examples make use of this data:</p><pre><code class="language-julia">using IncrementalInference
# Create a DFG with default solver parameters using the LightGraphs.jl driver.
dfg = LightDFG{SolverParams}(params=SolverParams())

x0 = addVariable!(dfg, :x0, ContinuousScalar, tags = [:POSE], solvable=1)
x1 = addVariable!(dfg, :x1, ContinuousScalar, tags = [:POSE], solvable=1)
f1 = addFactor!(dfg, [:x0; :x1], LinearConditional(Normal(50.0,2.0)), solvable=1)</code></pre><h2><a class="nav-anchor" id="Variable-and-Factor-Elements-1" href="#Variable-and-Factor-Elements-1">Variable and Factor Elements</a></h2><h3><a class="nav-anchor" id="Common-Elements-1" href="#Common-Elements-1">Common Elements</a></h3><h4><a class="nav-anchor" id="Labels-1" href="#Labels-1">Labels</a></h4><p>Labels are the principle identifier of a variable or factor.</p><ul><li><a href="../func_ref/#DistributedFactorGraphs.getLabel-Tuple{Union{DFGFactorSummary, DFGVariableSummary, SkeletonDFGFactor, SkeletonDFGVariable, DFGFactor, DFGVariable}}"><code>getLabel</code></a></li></ul><h4><a class="nav-anchor" id="Timestamps-1" href="#Timestamps-1">Timestamps</a></h4><p>Each variable or factor can have a timestamp associated with it.</p><ul><li><a href="../func_ref/#DistributedFactorGraphs.getTimestamp-Tuple{Union{DFGFactorSummary, DFGVariableSummary, DFGFactor, DFGVariable}}"><code>getTimestamp</code></a></li><li><a href="../func_ref/#DistributedFactorGraphs.setTimestamp!-Tuple{AbstractDFG,Symbol,TimeZones.ZonedDateTime}"><code>setTimestamp!</code></a></li></ul><h4><a class="nav-anchor" id="Tags-1" href="#Tags-1">Tags</a></h4><p>Tags are a set of symbols that contain identifiers for the variable or factor.</p><ul><li><a href="../func_ref/#DistributedFactorGraphs.listTags-Tuple{AbstractDFG,Symbol}"><code>listTags</code></a></li><li><a href="../func_ref/#DistributedFactorGraphs.mergeTags!-Tuple{LightDFG,Symbol,Array{Symbol,1}}"><code>mergeTags!</code></a></li><li><a href="../func_ref/#DistributedFactorGraphs.removeTags!-Tuple{LightDFG,Symbol,Array{Symbol,1}}"><code>removeTags!</code></a></li><li><a href="../func_ref/#DistributedFactorGraphs.emptyTags!-Tuple{LightDFG,Symbol}"><code>emptyTags!</code></a></li></ul><h3><a class="nav-anchor" id="Solvable-1" href="#Solvable-1">Solvable</a></h3><p>The solvable flag indicates whether the solver should make use of the variable or factor while solving the graph. This can be used to construct graphs in chunks while solving asynchronously, or for selectively solving portions of the graph.</p><ul><li><a href="../func_ref/#DistributedFactorGraphs.getSolvable-Tuple{AbstractDFG,Symbol}"><code>getSolvable</code></a></li><li><a href="../func_ref/#DistributedFactorGraphs.setSolvable!-Tuple{AbstractDFG,Symbol,Int64}"><code>setSolvable!</code></a></li></ul><h3><a class="nav-anchor" id="Variables-1" href="#Variables-1">Variables</a></h3><h4><a class="nav-anchor" id="Soft-Type-1" href="#Soft-Type-1">Soft Type</a></h4><p>The soft type is the underlying inference variable type, such as a Pose2.</p><ul><li><a href="../func_ref/#DistributedFactorGraphs.getSofttype-Tuple{VariableNodeData}"><code>getSofttype</code></a></li></ul><h4><a class="nav-anchor" id="Packed-Parametric-Estimates-1" href="#Packed-Parametric-Estimates-1">Packed Parametric Estimates</a></h4><p>Solved graphs contain packed parametric estimates for the variables, which are keyed by the solution (the default is saved as :default).</p><p>For each PPE structure, there are accessors for getting individual values:</p><ul><li><a href="@ref"><code>getMaxPPE</code></a></li><li><a href="@ref"><code>getMeanPPE</code></a></li><li><a href="@ref"><code>getSuggestedPPE</code></a></li></ul><p>Related functions for getting, adding/updating, and deleting PPE structures:</p><ul><li><a href="../func_ref/#DistributedFactorGraphs.listPPEs-Tuple{AbstractDFG,Symbol}"><code>listPPEs</code></a></li><li><a href="../func_ref/#DistributedFactorGraphs.getPPE"><code>getPPE</code></a></li><li><a href="../func_ref/#DistributedFactorGraphs.addPPE!"><code>addPPE!</code></a></li><li><a href="../func_ref/#DistributedFactorGraphs.updatePPE!"><code>updatePPE!</code></a></li><li><a href="../func_ref/#DistributedFactorGraphs.deletePPE!"><code>deletePPE!</code></a></li><li><a href="../func_ref/#DistributedFactorGraphs.mergePPEs!-Tuple{AbstractDFGVariable,AbstractDFGVariable}"><code>mergePPEs!</code></a></li></ul><p>Example of PPE operations:</p><pre><code class="language-julia"># Add a new PPE of type MeanMaxPPE to :x0
ppe = MeanMaxPPE(:default, [0.0], [0.0], [0.0])
addPPE!(dfg, :x0, ppe)
@show listPPEs(dfg, :x0)
# Get the data back - note that this is a reference to above.
v = getPPE(dfg, :x0, :default)
# Delete it
deletePPE!(dfg, :x0, :default)
# Update add it
updatePPE!(dfg, :x0, ppe, :default)
# Update update it
updatePPE!(dfg, :x0, ppe, :default)
# Bulk copy PPE&#39;s for x0 and x1
updatePPE!(dfg, [x0], :default)</code></pre><h4><a class="nav-anchor" id="Solver-Data-1" href="#Solver-Data-1">Solver Data</a></h4><p>Solver data is used by IncrementalInference/RoME/Caesar solver to produce the above PPEs.</p><p>Related functions:</p><ul><li><a href="../func_ref/#DistributedFactorGraphs.listVariableSolverData-Tuple{AbstractDFG,Symbol}"><code>listVariableSolverData</code></a></li><li><a href="../func_ref/#DistributedFactorGraphs.getVariableSolverData"><code>getVariableSolverData</code></a></li><li><a href="../func_ref/#DistributedFactorGraphs.addVariableSolverData!"><code>addVariableSolverData!</code></a></li><li><a href="../func_ref/#DistributedFactorGraphs.updateVariableSolverData!"><code>updateVariableSolverData!</code></a></li><li><a href="../func_ref/#DistributedFactorGraphs.deleteVariableSolverData!"><code>deleteVariableSolverData!</code></a></li><li><a href="../func_ref/#DistributedFactorGraphs.mergeVariableSolverData!-Tuple{DFGVariable,DFGVariable}"><code>mergeVariableSolverData!</code></a></li></ul><p>Example of solver data operations:</p><pre><code class="language-julia"># Add new VND of type ContinuousScalar to :x0
# Could also do VariableNodeData(ContinuousScalar())
vnd = VariableNodeData{ContinuousScalar}()
addVariableSolverData!(dfg, :x0, vnd, :parametric)
@show listVariableSolverData(dfg, :x0)
# Get the data back - note that this is a reference to above.
vndBack = getVariableSolverData(dfg, :x0, :parametric)
# Delete it
deleteVariableSolverData!(dfg, :x0, :parametric)</code></pre><h4><a class="nav-anchor" id="Small-Data-1" href="#Small-Data-1">Small Data</a></h4><p>Small data allows you to assign a dictionary to variables. It is a useful way to keep small amounts of string data in a variable. As it is stored in the graph itself, large entries will slow the graph down, so if data should exceed a few bytes/kb, it should rather be saved in bigData.</p><ul><li><a href="../func_ref/#DistributedFactorGraphs.getSmallData-Tuple{AbstractDFG,Symbol,Symbol}"><code>getSmallData</code></a></li><li><a href="../func_ref/#DistributedFactorGraphs.setSmallData!-Tuple{DFGVariable,Dict{Symbol,Union{Bool, Float64, Int64, Array{Bool,1}, Array{Float64,1}, Array{Int64,1}, Array{String,1}, String}}}"><code>setSmallData!</code></a></li></ul><p>Example:</p><pre><code class="language-julia">setSmallData!(x0, Dict(&quot;entry&quot;=&gt;&quot;entry value&quot;))
getSmallData(x0)</code></pre><h4><a class="nav-anchor" id="Big-Data-1" href="#Big-Data-1">Big Data</a></h4><h3><a class="nav-anchor" id="Factors-1" href="#Factors-1">Factors</a></h3><h2><a class="nav-anchor" id="Graph-Related-Data-1" href="#Graph-Related-Data-1">Graph-Related Data</a></h2><p>DFG can store data in the graph itself (as opposed to inside graph elements). When you retrieve graphs from a database, this information is carried along. If you are working with an in-memory graph, the structure is flattened into the graph itself as <code>userData</code>, <code>robotData</code>, and <code>sessionData</code>.</p><p>Graphs reside inside a hierarchy made up in the following way:</p><ul><li>User1<ul><li>Robot1<ul><li>Session1 (the graph itself)</li></ul></li></ul></li><li>User2<ul><li>Robot2</li><li>Robot3<ul><li>Session2</li><li>Session3</li></ul></li></ul></li></ul><p>This data can be retrieved with the follow functions:</p><ul><li><a href="../func_ref/#DistributedFactorGraphs.getUserData-Tuple{AbstractDFG}"><code>getUserData</code></a></li><li><a href="../func_ref/#DistributedFactorGraphs.getRobotData-Tuple{AbstractDFG}"><code>getRobotData</code></a></li><li><a href="../func_ref/#DistributedFactorGraphs.getSessionData-Tuple{AbstractDFG}"><code>getSessionData</code></a></li></ul><p>It can be set using the following functions:</p><ul><li><a href="../func_ref/#DistributedFactorGraphs.setUserData!-Tuple{AbstractDFG,Dict{Symbol,String}}"><code>setUserData!</code></a></li><li><a href="../func_ref/#DistributedFactorGraphs.setRobotData!-Tuple{AbstractDFG,Dict{Symbol,String}}"><code>setRobotData!</code></a></li><li><a href="../func_ref/#DistributedFactorGraphs.setSessionData!-Tuple{AbstractDFG,Dict{Symbol,String}}"><code>setSessionData!</code></a></li></ul><p>Example of using graph-level data:</p><pre><code class="language-julia">setUserData!(dfg, Dict(:a =&gt; &quot;Hello&quot;))
getUserData(dfg)</code></pre><footer><hr/><a class="previous" href="../BuildingGraphs/"><span class="direction">Previous</span><span class="title">Building Graphs</span></a><a class="next" href="../DrawingGraphs/"><span class="direction">Next</span><span class="title">Drawing Graphs</span></a></footer></article></body></html>
